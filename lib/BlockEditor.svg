<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.2" baseProfile="tiny">
    <style>
        /* Uncomment to enable font:
        @import url("//hello.myfonts.net/count/327c29");*/
        @font-face {
            font-family: Brandon-Grotesque-Regular;
            src: url('webfonts/2DA05D_0_0.eot');
            src: url('webfonts/2DA05D_0_0.eot?#iefix') format('embedded-opentype'), url('webfonts/2DA05D_0_0.woff2') format('woff2'), url('webfonts/2DA05D_0_0.woff') format('woff'), url('webfonts/2DA05D_0_0.ttf') format('truetype');
        }


        svg {
            background: #DDD;
        }
        .lid {
            filter: url(#lidShadow);
            fill: #DDD;
            transition: fill-opacity 1.0s;
        }
        .lid:hover {
            fill-opacity: 0.0;
        }
        .box {
            filter: url(#boxShadow);
            fill: #CCC;
        }
        .arrow {
            fill: #FFF;
        }
        .label {
            fill: black;
            text-anchor: middle;
            font-family: Brandon-Grotesque-Regular,Helvetica-Bold,sans-serif;
            font-size: 18px;
            font-weight: bold;
        }
    </style>

    <defs>
        <filter id="boxShadow">
            <feGaussianBlur in="SourceAlpha" stdDeviation="5" result="blur" />
            <feComponentTransfer in="blur" result="inverse-blur">
                <feFuncA type="linear" slope="-1" intercept="1" />
            </feComponentTransfer>
            <feComposite operator="in" in="SourceAlpha" in2="inverse-blur" result="clipped-blur" />
            <feComposite operator="over" in="clipped-blur" in2="SourceGraphic" />
        </filter>
        <filter id="lidShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feComponentTransfer in="SourceAlpha" result="soft-alpha">
                <feFuncA type="linear" slope="0.4" intercept="0" />
            </feComponentTransfer>
            <feGaussianBlur in="soft-alpha" result="blur" stdDeviation="3" />
            <feComposite operator="over" in="SourceGraphic" in2="blur" />
        </filter>
        <filter id="arrowShadow">
            <feComponentTransfer in="SourceAlpha" result="soft-alpha">
                <feFuncA type="linear" slope="0.2" intercept="0" />
            </feComponentTransfer>
            <feGaussianBlur in="soft-alpha" result="blur" stdDeviation="2" />
            <feComposite operator="over" in="SourceGraphic" in2="blur" />
        </filter>
        <filter id="alphaBlur" x="-50%" y="-50%" width="150%" height="200%" primitiveUnits="userSpaceOnUse">
            <feGaussianBlur in="SourceAlpha" stdDeviation="5" />
        </filter>
        <linearGradient id="slopeShadowGradient">
            <stop offset="0.0" stop-opacity="0.0" />
            <stop offset="0.2" stop-opacity="0.6" />
            <stop offset="1.0" stop-opacity="0.2" />
        </linearGradient>
        <linearGradient id="slopeDiffuseGradient">
            <stop offset="0.0" stop-opacity="0.0" />
            <stop offset="0.4" stop-opacity="0.1" />
            <stop offset="0.6" stop-opacity="0.1" />
            <stop offset="1.0" stop-opacity="0.0" />
        </linearGradient>
        <pattern id="slopeShadow" width="1" height="1">
            <path fill="url(#slopeShadowGradient)" filter="url(#alphaBlur)" />
        </pattern>
        <pattern id="slopeDiffuse" width="1" height="1" patternContentUnits="objectBoundingBox">
            <rect x="0" y="0.25" width="1" height="0.5" fill="url(#slopeDiffuseGradient)" />
        </pattern>
        <pattern id="diagonalStripes" width="16" height="16" patternUnits="userSpaceOnUse" patternTransform="rotate(45) translate(5 0)">
            <rect x="0" y="0" width="8" height="16" opacity="0.1" />
        </pattern>
        <pattern id="dots" width="4" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(30)">
            <rect x="0" y="0" width="2" height="2" opacity="0.2" />
        </pattern>
    </defs>

    <!--<rect width="100%" height="100%" fill="url(#dots)" />-->

    <g id="boxes"/>
    <rect width="100" height="100" x="200" y="100" rx="10" ry="10" fill="url(#diagonalStripes)" />
    <g id="arrows"/>
    <g id="labels"/>
    <g id="lids"/>

    <script>
        // <![CDATA[
        "use strict";

        const svg = document.documentElement;
        const svgNS = svg.namespaceURI;
        const gridSize = 50;
        const labelHOffset = gridSize;
        const labelVOffset = 6;
        const cornerRadius = 10;
        const arrowWidth = 25;
        const arrowStartOutset = -0.5 * gridSize;
        const arrowStartInset = -15;
        const arrowEndOutset = 15;
        const arrowEndInset = 0.5 * gridSize;
        // directions = ['right', 'down', 'left', 'up'];

        function init() {
            const lower = arrowWidth * 0.4, higher = arrowWidth * 1.4, diff = (higher - lower) * 0.5,
                slopeShadow = document.getElementById('slopeShadow').children[0];
            slopeShadow.setAttribute('d', 'M0,' + (gridSize - lower) * 0.5 + 'l' + gridSize + ',' + (-diff) + 'v' + higher + 'l' + (-gridSize) + ',' + (-diff) + 'v' + lower + 'z');
        }

        function generateBlock(block) {
            const path = document.createElementNS(svg.namespaceURI, 'rect');
            path.setAttribute('class', (block.isLid) ? 'lid' : 'box');
            path.setAttribute('rx', cornerRadius);
            path.setAttribute('ry', cornerRadius);
            path.setAttribute('x', block.x * gridSize);
            path.setAttribute('y', block.y * gridSize);
            path.setAttribute('width', block.width * gridSize);
            path.setAttribute('height', block.height * gridSize);
            document.getElementById((block.isLid) ? 'lids' : 'boxes').appendChild(path);

            const group = document.getElementById('labels');
            for (var index in block.ports) {
                const port = block.ports[index];

                var label = document.createElementNS(svg.namespaceURI, 'text'),
                    angle = port.dir * 90,
                    xOffset = (block.x + port.x) * gridSize, yOffset = (block.y + port.y) * gridSize;
                switch (port.dir) {
                    case 0:
                        xOffset += labelHOffset;
                        yOffset += labelVOffset;
                        break;
                    case 1:
                        xOffset -= labelVOffset;
                        yOffset += labelHOffset;
                        break;
                    case 2:
                        angle = 0;
                        xOffset -= labelHOffset;
                        yOffset += labelVOffset;
                        break;
                    case 3:
                        xOffset += labelVOffset;
                        yOffset -= labelHOffset;
                        break;
                }
                label.setAttribute('class', 'label');
                // label.setAttribute('text-anchor', (slope.dir == 2) ? 'end' : 'start');
                label.setAttribute('transform', 'translate(' + xOffset + ',' + yOffset + ') rotate(' + angle + ')');
                label.textContent = port.label;
                group.appendChild(label);
            }
        }

        function generateArrow(arrow) {
            var prevDir = arrow.segments[0].dir, xOffset = 0, yOffset = 0;
            if (prevDir == 0 || prevDir == 2) {
                xOffset = arrowStartInset;
                if (prevDir == 2)
                    xOffset *= -1;
                else
                    xOffset += gridSize;
            } else {
                yOffset = arrowStartInset;
                if (prevDir == 3)
                    yOffset *= -1;
                else
                    yOffset += gridSize;
            }
            var forward = 'M' + (arrow.x * gridSize + xOffset) + ',' + (arrow.y * gridSize + yOffset), backward = 'z';

            function generateCap(dir, end) {
                var tag, inset, outset, forwardDiagonal, backwardDiagonal,
                    diagonalO = arrowWidth * 0.5;
                if (end) {
                    inset = -arrowEndInset;
                    outset = -arrowEndOutset;
                    diagonalO *= -1;
                } else {
                    inset = arrowStartInset;
                    outset = arrowStartOutset;
                }
                var parallel = outset, diagonalP = outset - inset;
                if (dir == 0 || dir == 1) {
                    diagonalO *= -1;
                    parallel *= -1;
                }
                if (dir >= 2)
                    diagonalP *= -1;
                if (dir == 0 || dir == 2) {
                    tag = 'h';
                    forwardDiagonal = diagonalP + ',' + diagonalO;
                    backwardDiagonal = (-diagonalP) + ',' + diagonalO;
                } else {
                    tag = 'v';
                    forwardDiagonal = diagonalO + ',' + diagonalP;
                    backwardDiagonal = diagonalO + ',' + (-diagonalP);
                }
                if (end) {
                    forward += tag + parallel + 'l' + forwardDiagonal;
                    backward = 'l' + backwardDiagonal + tag + (-parallel) + backward;
                } else {
                    forward += 'l' + forwardDiagonal + tag + parallel;
                    backward = tag + (-parallel) + 'l' + backwardDiagonal + backward;
                }
            }

            generateCap(prevDir, false);
            for (const index in arrow.segments) {
                const segment = arrow.segments[index],
                    nextDir = segment.dir;
                if (prevDir != -1 && prevDir != nextDir) {
                    var radiusF, radiusB, xF, yF,
                        srcF = (prevDir >= 2) ? -1 : 1,
                        dstF = (nextDir >= 2) ? -1 : 1,
                        sweepFlag = ((prevDir + 1) % 4 == nextDir) ? 1 : 0;
                    if (sweepFlag == 1) {
                        xF = dstF;
                        yF = srcF;
                    } else {
                        xF = srcF;
                        yF = dstF;
                    }
                    radiusF = gridSize * 0.5 + arrowWidth * (sweepFlag - 0.5);
                    radiusB = gridSize * 0.5 + arrowWidth * (0.5 - sweepFlag);
                    forward += 'a' + radiusF + ',' + radiusF + ',0,0,' + sweepFlag + ',' + (radiusF * xF) + ',' + (radiusF * yF);
                    backward = 'a' + radiusB + ',' + radiusB + ',0,0,' + (1 - sweepFlag) + ',' + (-radiusB * xF) + ',' + (-radiusB * yF) + backward;
                }
                if (segment.distance > 0) {
                    var tag = (nextDir == 0 || nextDir == 2) ? 'h' : 'v',
                        distance = segment.distance * gridSize;
                    if (nextDir >= 2)
                        distance *= -1;
                    forward += tag + distance;
                    backward = tag + (-distance) + backward;
                }
                prevDir = nextDir;
            }
            generateCap(prevDir, true);

            const group = document.getElementById('arrows');

            function generateSlope(type, slope) {
                var rect = document.createElementNS(svg.namespaceURI, 'rect'),
                    xOffset = slope.x * gridSize, yOffset = slope.y * gridSize;
                if (slope.dir == 1 || slope.dir == 3)
                    xOffset -= gridSize * 0.5;
                else
                    yOffset -= gridSize * 0.5;
                rect.setAttribute('transform', 'translate(' + xOffset + ',' + yOffset + ') rotate(' + (slope.dir * 90) + ',' + gridSize * 0.5 + ',' + gridSize * 0.5 + ')');
                rect.setAttribute('fill', 'url(#' + type + ')');
                rect.setAttribute('width', gridSize);
                rect.setAttribute('height', gridSize);
                group.appendChild(rect);
            }

            for (const index in arrow.slopes)
                generateSlope('slopeShadow', arrow.slopes[index]);

            var path = document.createElementNS(svg.namespaceURI, 'path');
            path.setAttribute('class', 'arrow');
            path.setAttribute('filter', 'url(#arrowShadow)');
            path.setAttribute('d', forward + backward);
            group.appendChild(path);

            for (const index in arrow.slopes)
                generateSlope('slopeDiffuse', arrow.slopes[index]);
        }

        init();

        const blocks = [
            {
                x: 3, y: 1,
                width: 7, height: 6,
                ports: [
                    {x: 7, y: 5, dir: 0, label: 'Happen'}
                ]
            },
            {x: 4, y: 2, width: 2, height: 2},
            {x: 4, y: 2, width: 2, height: 2, isLid: true}
        ];

        const arrows = [
            {
                x: 4, y: 3,
                segments: [
                    {dir: 0, distance: 3},
                    {dir: 1, distance: 2},
                    {dir: 0, distance: 3}
                ],
                slopes: [
                    {dir: 0, x: 5, y: 3},
                    {dir: 0, x: 9, y: 6}
                ]
            },
            {
                x: 4, y: 6,
                segments: [{dir: 2, distance: 3}],
                slopes: [{dir: 2, x: 3, y: 6}]
            },
            {
                x: 0, y: 5,
                segments: [{dir: 0, distance: 3}],
                slopes: [{dir: 2, x: 3, y: 5}]
            }];


        for (const index in blocks)
            generateBlock(blocks[index]);

        for (const index in arrows)
            generateArrow(arrows[index])
        // ]]>
    </script>
</svg>
